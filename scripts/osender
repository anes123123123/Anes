#!/usr/bin/env python
#
# osender - offline (cold) transaction broadcaster utility
# Copyright (C) 2013 TradeHill Inc
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import re
import pkgutil
import sys, os, time, json
from os import path
from glob import glob
import optparse
import platform
from decimal import Decimal

try:
    import ecdsa  
except ImportError:
    sys.exit("Error: python-ecdsa does not seem to be installed. Try 'sudo pip install ecdsa'")

try:
    import aes
except ImportError:
    sys.exit("Error: AES does not seem to be installed. Try 'sudo pip install slowaes'")


is_local = os.path.dirname(os.path.realpath(__file__)) == os.path.join(os.getcwd(), 'scripts')
is_android = 'ANDROID_DATA' in os.environ

import __builtin__
__builtin__.use_local_modules = is_local or is_android

# load local module as electrum
if __builtin__.use_local_modules:
    import imp
    imp.load_module('electrum', *imp.find_module('../lib'))

from electrum import *

def arg_parser():
    usage = """usage: %prog [options] DIR ...
Sends all signed transactions files of the form *.stxn in each directory.
After signing, each file is moved into an archive subdirectory.
""" 
    parser = optparse.OptionParser(prog=usage)
    parser.add_option("-w", "--wallet", dest="wallet_path", help="wallet path (default: electrum.dat)")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="show debugging information")
    parser.add_option("-s", "--server", dest="server", default=None, help="set server host:port:protocol, where protocol is t or h")
    return parser

def print_outputs(outs, wallet):
    for out in outs:
        address, amount = out
        if wallet.is_mine(address):
            print "    CHANGE:%s -> %s"%(util.format_satoshis(amount, False), address)
        else:
            print "    OUT   :%s -> %s"%(util.format_satoshis(amount, False), address)

def connect_wallet(wallet):
    interface = Interface(config)
    interface.register_callback('connected', lambda: sys.stderr.write("Connected to " + interface.connection_msg + "\n"))
    if not interface.start(wait=True):
        print_msg("Not connected, aborting.")
        sys.exit(1)
    wallet.interface = interface
    verifier = WalletVerifier(interface, config)
    verifier.start()
    wallet.set_verifier(verifier)
    synchronizer = WalletSynchronizer(wallet, config)
    synchronizer.start()
    wallet.update()
    wallet.save()

if __name__ == '__main__':

    parser = arg_parser()
    options, args = parser.parse_args()
    set_verbosity(options.verbose)

    # config is an object passed to the various constructors (wallet, interface, gui)
    if is_android:
        config_options = {'wallet_path':"/sdcard/electrum.dat", 'portable':True, 'verbose':True, 'gui':'android', 'auto_cycle':True}
    else:
        config_options = eval(str(options))
        for k, v in config_options.items():
            if v is None: config_options.pop(k)

    config = SimpleConfig(config_options)
    wallet = Wallet(config)
    connect_wallet(wallet)

    if not config.wallet_file_exists:
        print_msg("Error: Wallet file not found.")
        sys.exit(1)

    tx_files = []
    for tx_dir in args:
        tx_files = tx_files + glob(path.join(tx_dir, '*.stxn'))
        archive_dir = path.join(tx_dir, 'archive')
        if not path.isdir(archive_dir):
            os.mkdir(archive_dir)

    for signed_file in tx_files:
        print signed_file + ":"
        archive_dir = path.join(path.dirname(signed_file), 'archive')
        archived_signed_file = path.join(archive_dir, path.basename(signed_file))

        if path.isfile(archived_signed_file):
            print "%s already exists!"%(archived_signed_file)
            sys.exit(1)

        signed_tx = json.load(open(signed_file, "rb"))
        if not signed_tx['complete']:
            print "Signed tx not marked as complete by signer"
            sys.exit(1)
        raw_tx = signed_tx['hex']
        tx = Transaction(raw_tx)
        print_outputs(tx.outputs, wallet)
        print "    https://blockchain.info/search/%s"%(tx.hash())
        if not raw_input('Send? ').startswith('y'):
            sys.exit(0)
        r, h = wallet.sendtx( tx )
        print h
        os.rename(signed_file, archived_signed_file)
        print
